<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Cocoapods 创建私有Pod]]></title>
    <url>%2F2018%2F06%2F23%2FPrivatePod%2F</url>
    <content type="text"><![CDATA[iOS 开发中我们经常用 CocoaPods 来安装第三方库，CocoaPods 可以帮助我们处理依赖，管理版本等等，还是挺方便的，如果我们公司内部有一个比较独立的组件，不相开源但是又想用 CocoaPods 来管理，可不可以呢？当然是可以的，CocoaPods 也提供了比较好的支持，可以自定义源，这样只要我们把 Pods 源和组件的源代码的权限放到私有的空间里，其他和公开仓库的作法是类似的。下面就简单说一下怎么创建私有的 CocoaPods 仓库。 下文中的 CocoaPods 使用的是 1.1.1 版本 创建样板工程CocoaPods 提供了工具可以创建一个样板工程，在终端中 cd 到一个方便操作的目录，运行如下命令：1pod lib create GetMyIPAddress GetMyIPAddress 就是你工程的名字，记得修改为自己的。执行操作以后会出现如下提示： 要使用的语言？（OC or swift） 是否需要样例工程 (一般是需要的) 是否需要一个测试框架 （看具体情况，具体框架先不展开，有兴趣的可以研究下） 是否需要基于 View 的测试 （没太明白） 还有类的前缀 （一般需要，填写自己的） 执行完成后会自动打开 Xcode，完成后在当前目录会出现一个 GetMyIPAddress 目录，cd 到这个目录中，我们可以看到如下文件 把组件相关的类放到工程中关闭Xcode，进入到文件目录，手动把组件相关的类放到 GetMyIPAddress/Classes 目录中，删除自带的ReplaceMe.m，这里之所以要放到这个目录下是因为 Example 工程是中生成 Podfile 文件中指定了这个目录是源文件地址，我们按照默认的走就好。这里我们创建了一个类，导入了这个测试文件，共2个文件放到 Classes 文件夹，如下： 资源文件第一种：直接访问 resource1234567#单个路径spec.resource = 'Resources/HockeySDK.bundle'#多个路径spec.resources = ['Images/\*.png', 'Sounds/\*'] #图片文件夹spec.resource = 'Resources/*.xcassets' 但是这些资源会在打包的时候直接拷贝的app的Bundle中，这样说不定会和其它资源产生命名冲突。如果是自建.xcassets的方式，pod里面所有的图都会在打包后和主工程的.xcassets进行合并，会有极大的可能造成冲突的问题。 pod中资源获取： 123UIImage *image = [UIImage imageNamed:@"your-image-name" inBundle:[NSBundle bundleForClass:[self class]] compatibleWithTraitCollection:nil]; 第二种：resource_bundle手动把组件相关的资源放到 GetMyIPAddress/Assets 目录中，同时编辑podspec文件：12345678# 类文件s.source_files = 'HomeRefresh/Classes/**/*'# 资源文件存放s.resource_bundles = &#123; 'GetMyIPAddress' =&gt; ['GetMyIPAddress/Assets/*.xcassets'] &#125;# 第一个参数是 对应的bundle名字# 第二个参数是路径 在工程中的文件读取需要注意一下，参考 这种方法利用 framework 的命名空间，有效防止了资源冲突。以图片资源为例： 123456789101112//从自己模块的bundle里取出资源，并非mainBundle- (UIImage *)getImageFromBundleWithName:(NSString *)name &#123; //1 得到自己的类名 NSString *className = NSStringFromClass([self class]); //2 得到自己的bundle NSBundle *bundle = [NSBundle bundleForClass:[self class]]; NSURL *url = [bundle URLForResource:className withExtension:@"bundle"]; NSBundle *targetBundle = [NSBundle bundleWithURL:url]; UIImage *image = [UIImage imageNamed:name inBundle:targetBundle compatibleWithTraitCollection:nil];&#125; 依赖库依赖关系大致分为以下几种情况： 第三方的公有库，例如AFN 自己包装的SDK ，例如xxx.a,xxx.framework 系统的framework，tbd 自己的私有库相对应的关键字： vendored_libraries: 第三方.a文件 frameworks: 该pod依赖的系统framework libraries: 该pod依赖的系统library spec.dependency ‘AFNetworking’, ‘~&gt; 3.1.0’1234567891011121314# 类s.source_files = 'CMNewPayLib/Classes/**/*','CMNewPayLib/ThirdParty/*.&#123;h&#125;'#第三方.a文件 s.vendored_libraries = 'CMNewPayLib/ThirdParty/*.&#123;a&#125;'#第三方.framework文件 s.vendored_frameworks = 'CMNewPayLib/ThirdParty/*.&#123;framework&#125;'#资源文件 s.resource_bundles = &#123;'Resources' =&gt; 'CMNewPayLib/ThirdParty/*.&#123;bundle&#125;'&#125;#系统的依赖库 s.frameworks = 'SystemConfiguration','CoreGraphics','CoreTelephony','Security','CoreLocation','JavaScriptCore'#系统的lib s.libraries = 'iconv','sqlite3','stdc++','z'#依赖库 s.dependency 'AFNetworking', '~&gt; 2.3' 更新Example工程之后我们需要更新 Example 工程，在终端中 cd 到 Example 目录下并运行 pod install 命令CocoaPods 会更新 pod，这里直接从之前的 Classes 文件夹中获取文件更新，完成后我们再看回 Xcode 是上目录树，添加的三个文件出现在了 Development Pods 下 导入头文件测试此时我们可以在测试一下，在 ViewController 导入这个框架，看看能不能使用，会不会报错编译通过的话，问题就不多了。如果提示找不到自己的头文件，问题大部分都是自己传进来的代码有语法错误，并不是真正的找不到头文件。 编辑 podspec 文件接下来我们要编辑 podspec 文件，在样板工程的根目录下有一个 GetMyIPAddress.podspec 文件，用文本编辑器打开，需要 summary, homepage 和 source 字段，其中 source 字段是刚刚把源码上传到的 Git 仓库地址，需要用 HTTPS 链接，source_files 字段和默认的一样，不用修改，因为我们之前就是把源文件放到这个目录的。 注意！！如果你并不是用工具创建的工程也不需要demo，podspec文件需要自己手动创建 1pod spec create GetMyIPAddress 打开 GetMyIPAddress.podspec ，由于是用工具创建的，我们几乎不需要修改什么东西，如果手动创建，就需要注意 source_files的填写，文件内的目录是以 podspec 文件的位置为基础的。刚才自动生成的文件内容应该如下 123456789101112131415Pod::Spec.new do |s| s.name = 'GetMyIPAddress' s.version = '0.1.0' s.summary = 'A short description of GetMyIPAddress.' s.description = &lt;&lt;-DESCTODO: Add long description of the pod here. DESC s.homepage = 'https://github.com/&lt;GITHUB_USERNAME&gt;/GetMyIPAddress' s.license = &#123; :type =&gt; 'MIT', :file =&gt; 'LICENSE' &#125; s.author = &#123; 'xxx' =&gt; 'xxx@xxx.com' &#125; s.source = &#123; :git =&gt; 'https://github.com/&lt;GITHUB_USERNAME&gt;/GetMyIPAddress.git', :tag =&gt; s.version.to_s &#125; s.platform = :ios s.ios.deployment_target = '7.0' s.source_files = 'GetMyIPAddress/Classes/**/*' 其中最重要的是把 s.source 的路径替换为你代码存放的git地址 s.summary 最好改动一下，完全不改会有警告 s.description 要比 s.summary 字数多，不然警告 s.platform 最好加上，不然警告 s.ios.deployment_target = ‘7.0’ 对应Podfile里面的platform关键字，最低支持版本。 s.dependency ‘AFNetworking’, ‘~&gt; 2.3’ 这个私有库依赖AFN。如果是依赖自己的私有库，暂时参考这个，具体思路我也在摸索。 完成编写spec后，继续执行 pod install 命令 整理了下常用的关键字，如有需要请参考官方文档 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Pod::Spec.new do |s|# 名称 使用的时候pod search [name]s.name = "DropDownMenu"# 代码库的版本s.version = "1.0.0"# 简介s.summary = "DropDownMenu double tableView, The optimization version ，new add image,detailText."# 详细描述s.description = &lt;&lt;-DESC Testing Private Podspec. * Markdown format. * Don't worry about the indent, we strip it! DESC# 主页s.homepage = "https://github.com/XXXXXX"# 许可证书类型，要和仓库的LICENSE 的类型一致s.license = &#123; :type =&gt; 'MIT', :file =&gt; 'LICENSE' &#125;# 作者名称 和 邮箱s.author = &#123; "Tyler" =&gt; "12345678@qq.com" &#125;# 作者主页 s.social_media_url ="xxxxx.com"# 代码库最低支持的版本s.platform = :ios, "7.0"# 代码的Clone 地址 和 tag 版本s.source = &#123; :git =&gt; "http:XXXXX.git", :tag =&gt; s.version.to_s &#125;#代码源文件地址，**/*表示Classes目录及其子目录下所有文件，如果有多个目录下则用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置s.source_files = "Pod/Classes/**/*.&#123;h,m&#125;"#公开头文件地址s.public_header_files = 'Pod/Classes/**/*.h'# 不显示的头文件，内部使用，但是用户不会下到s.exclude_files = 'PaymentSDK/WXApi.h','PaymentSDK/WXApiObject.h'#资源文件地址s.resource_bundles = &#123; 'PodTestLibrary' =&gt; ['Pod/Assets/*.png']&#125; s.resources = ['PaymentSDK/AlipaySDK.bundle','PaymentSDK/PaymentImage.bundle']# 依赖的库文件，不需要写 .frameworks.frameworks = 'CoreMotion', "SystemConfiguration", "UIKit", "Security"# 工程需要依赖的 tbd 文件，不需要写文件名和前缀 "lib",对应 libc++.tbd,libz.tbd,libxm2.0.tbds.libraries = "c++", "z", "xml2", "sqlite3"# 工程中用到的自己公司的或者自己的私有库，路径写全s.vendored_frameworks = 'PaymentSDK/MyAPP.framework'# 框架是否使用的ARCs.requires_arc = true# 工程文件的配置，HEADER_SEARCH_PATHS =》 libxml2s.xcconfig = &#123; "HEADER_SEARCH_PATHS" =&gt; "$(SDKROOT)/usr/include/libxml2" &#125;# 如果你的库里包含其他静态库，需要添加这个选项s.user_target_xcconfig = &#123; 'CLANG_ALLOW_NON_MODULAR_INCLUDES_IN_FRAMEWORK_MODULES' =&gt; 'YES' &#125;end 注意xcconfig配置项，这里有两个配置参数： s.user_target_xcconfig 是对于编译工程中所有pod的设置 s.pod_target_xcconfig 只是针对当前pod 这里的问题是对于Xcode中繁多的 Build Setting 我怎么找到其 key-value，这里就使用到了Quick help 功能 ： 显示结果为： ps. 额外补充一下 subspec 利用 s.source_files = &quot;Pod/Classes/**/*.{h,m}&quot;的方式引入源代码，在实际工程被引入以后，你会发现所有的文件都是混在一起的，我们有时是需要把每个工程的文件独立出来处理的。但是最终生成的Pod库，所有的源文件只会在一个目录下： 我们利用 subspec解决这个问题： 1234567891011121314151617181920212223# 第一层 # s.source_files = 'HoriHomeModule/Classes/**/*' # 第二层 |xxx| 注意xxx必须是小写的字母！！！！s.subspec 'Service' do |service| service.source_files = 'HoriHomeModule/Classes/Service/*' service.public_header_files = 'HoriHomeModule/Classes/Service/*.h' end # 第二层 s.subspec 'Home' do |home| # home.source_files = 'HoriHomeModule/Classes/Home' # 第三层 home.subspec 'Controller' do |controller| controller.source_files = 'HoriHomeModule/Classes/Home/**/*' # 如果Home/Controller目录下的文件依赖与Service目录下文件，这个依赖关系一定要写 # 而且注意路径，这里是HoriHomeModule/Service，而不是HoriHomeModule/Classes/Service controller.dependency 'HoriHomeModule/Service' end end # 第二层 s.subspec 'Module' do |modules| modules.source_files = 'HoriHomeModule/Classes/Module/*' # 如果Module目录下的文件依赖与Service目录下文件，这个依赖关系一定要写 modules.dependency 'HoriHomeModule/Service' end 最终效果如下： 测试 podspec 文件是否可用在podspec目录，执行如下命令 12345pod lib lint或者忽视警告：pod lib lint xxx.podspec --verbose --allow-warnings如果包含静态库：pod lib lint xxx.podspec --use-libraries --verbose --allow-warnings 出现如下所示，即为成功 准备上传创建 specRepo (版本索引)我们要做私有的 pod，就不能放在公共的仓库里，这里我们新建一个git仓库，专门放我们的私有 podspec 文件.作用： 专门用来存储 spec 文件 需要单独对应一个 git 仓库，如果是公司内部，所有人的远程 git 地址都应该是同一个 有了索引，在 podfile 里面才可以用版本号进行控制 123pod repo add PrivateSpecsRepo http://xxx/PrivateSpecsRepo.git# 第一个参数是 本地的 repo 名字,以后每次 提交新的 repo 需要记住这个名字# repo add 命令每台滇南只需要执行一次 完成后，进入自己电脑的 ~/.cocoapods/repos的目录，检查是否创建了 PrivateSpecsRepo 目录。 上传工程创建一个工程的git目录地址，回到工程的根目录，执行如下： 1234567git add .git commit -m "first commit"git remote add origin https://xxx/GetMyIPAddress.gitgit push origin master# 记得必须打上 taggit tag -m "first release" "0.1.0"git push --tags #推送tag到远端仓库 上传 podSpec1 我们已经创建了 podspec 文件2 我们已经创建了 specRepo ，也在本地做了repo add操作,但是远程的 repo 的 git 里面还是空的。回到工程的根目录，执行如下操作：(参数是 1:repo的名字 2: spec文件) 12pod repo push PrivateSpecsRepo GetMyIPAddress.podspec#第一个参数就是你本地的 repo 名字，以后每次新的库都需要 repo push 有错误的话就继续修改 spec 文件，完了再次提交。成功后进入~/.cocoapods/repos的目录，显示如下就是正常。 正常的远程索引 git 仓库如下： 测试新建工程，创建Podfile文件，编辑如下 12345platform :ios, '8.0'target 'TestNewPods' do pod 'GetMyIPAddress',:git =&gt; 'http://192.168.1.151/xxx/GetMyIPAddress.git' :tag =&gt; '1.0.0'end 执行 pod install ，一切正常后打开新的 workspace，就可以看到自己的工程里加入了自己的库。如果包含静态库和bundle之类的 私有库依赖另一个自己的私有库如果我们在编写自己的私有库的时候遇到依赖另一个自己的私有库的情况。 首先在自己的 spec文件里添加依赖12#依赖库s.dependency 'XXXX', '~&gt; 2.3' 在 demo 工程里的 Podfile 里面添加私有库 Repo 的地址12source 'http://xxx/IOS/PrivateSpecsRepo.git'source 'https://github.com/CocoaPods/Specs.git' 执行 pod install，正常的话自己库可以被下载到工程里面，编译运行自己的工程，检查代码是否可以正常运行。 上传在完成自己的 demo 编写后，需要验证自己的 spec 文件，和一般的校验方式有所不同,需要指明自己私有库 repo 的地址和共有库的 repo 地址12如果是依赖私有库需要如下验证pod lib lint xxx.podspec --sources='http://xxx/IOS/PrivateSpecsRepo.git,https://github.com/CocoaPods/Specs.git' 如果没有问题，就可以安装正常的流程推到远程地址和私有 repo 库。 cocoapods-packager 打包类库需要使用一个cocoapods的插件cocoapods-packager来完成类库的打包。当然也可以手动编译打包，但是过程会相当繁琐。1、 安装打包插件,终端执行以下命令.1sudo gem install cocoapods-packager 2、 打包命令。命令很简单，执行123//参数--library 生成 .a 不加这个参数会生成framework//--force是指强制覆盖pod package Test.podspec --library --force 生成的库文件所有的架构（armv7 armv7s i386 x86_64 arm64 ）都是全的，直接使用即可。最终的目录结构如下： |____Test.podspec |____ios | |____libTest.a 需要特别强调的是，该插件通过对引用的三方库进行重命名很好的解决了类库命名冲突的问题。3、其中podSpec文件中的设置项 s.public_header_files可以指定生成framework暴露出来的头文件，如果是生成.a的话，需要手动把.h文件带上即可。 参考资料CocoaPods 常见错误CocoaPods 私有库创建、维护、升级CocoaPods 创建私有库，相对完善和可操作PodSpec 文件编辑的官方文档私有库中遇到的坑私有Cocoapods仓库 中高级用法The Podfile 官方文档私有库依赖私有库私有库管理和模块化管理使用CocoaPods开发并打包静态库Pod 中资源引入方式对比关于 Pod 库的资源引用 resource_bundles or resourcespodspec疑难点基于私有仓库的pod创建问题podspec文件的常用配置]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态库Framework 的制作]]></title>
    <url>%2F2018%2F03%2F06%2FFramework%2F</url>
    <content type="text"><![CDATA[静态库Framework 的制作目的诚然制作 Framework 并非什么技术难题，但其中的一些概念也可以加深我们对 编译、 iOS 或者 Mac 相关的了解，也随着 Xcode 的不断升级，制作Framework 也有不少不大不小的坑，在这里也统一收集记录下来。 简介Mac OS X扩展了framework的功能，让我们能够利用它来共享代码和资源。通过framework我们可以共享所有形式的资源，如动态共享库，nib文件，图像字符资源以及文档等。系统会在需要的时候将framework载入内存中，多个应用程序可以同时使用同一个framework。这种方法可以使得你的代码易分享，在多个工程中复用，并且可以隐藏实现细节，控制公开的头文件。 相关概念动态库 VS 静态库 Static frameworks are linked at compile time. Dynamic frameworks are linked at runtime 首先你得搞清楚，这两个东西都是编译好的二进制文件。就是用法不同而已。为什么要分为动态和静态两种库呢？先看下图：我们可以很清楚的看到: 对于一个静态库而言，其实已经是编译好的了,类似一个 .o 的集合（这里并没有连接过程）。在 build 的过程中只会参与链接的过程，而这个链接的过程简单的讲就是合并，并且链接器只会将静态库中被使用的部分合并到可执行文件中去。相比较于动态库，静态库的处理起来要简单的多，具体如下图： 链接器会将所有.o用到的 global symbol 和 unresolved symbol 放入一个临时表，而且是 global symbol 是不能重复的。 对于静态库的 .o , 连接器会将没有任何 symbol 在 unresolved symbol table 的给忽略。 unresolved symbol 类似 extern int test(); — .h 的 声明? global symbol 类似 void test() { print(&quot;test&quot;)} – .m 的 实现? 最后，链接器会用函数的实际地址来代替函数引用。 动态库的处理方式 首先，对于动态库而言其实分 动态链接库 和 动态加载库 两种的，这两个最本质的区别还是加载时间。 动态链接库：在没有被加载到内存的前提下，当可执行文件被加载，动态库也随着被加载到内存中。在 Linked Framework and Libraries 设置的一些 share libraries。【随着程序启动而启动】 动态加载库：当需要的时候再使用 dlopen 等通过代码或者命令的方式来加载。【在程序启动之后】 但是不论是哪种动态库，相比较与静态库，动态库处理起来要棘手的多。由于动态库是动态的，所以你事先不知道某个函数的具体地址。因此动态链接器在链接函数的时候需要做大量的工作。 因为动态库在链接函数需要做大量的工作，而静态库已经实现处理好了。所以单纯的在所有都没有加载的情况下，静态库的加载速度会更快一点。虽然动态库更加耗时，但是对于在加载过的share libraries不需要再加载的这个前提下，使用动态库可以节省一些启动时间。 而实现这个动态链接是使用了 Procedure Linkage Table (PLT)。首先这个 PLT 列出了程序中每一个函数的调用，当程序开始运行，如果动态库被加载到内存中，PLT 会去寻找动态的地址并记录下来，如果每个函数都被调用过的话，下一次调用就可以通过 PLT 直接跳转了，但是和静态库还是有点区别的是，每一个函数的调用还是需要通过一张 PLT。所有静态链接做的事情都搬到运行时来做了，会导致更慢 的原因。 动态库到底在内存哪块区域的问题 首先，不管是静态库、动态库，两者的区别和在内存哪个区域没有关系，最本质的区别是，一个的函数调用等在编译时候就已经确定，而动态库是动态加载的。换句话说，静态库修改了东西，整个程序需要重新编译，而对于动态库的修改而言，只需要重启 app（重置 PLT ）。 至于在内存的哪个区域，和 静态库 or 动态库 没有关系。代码段、数据段这些，都是程序加载时就进入的。堆一般是文件buffer分配、对象初始化等时候用的。栈是函数出入口指针，局部常规变量用的。只要 malloc 都在堆里。具体的可以参照这里 还需要提一下的是，如果是动态加载库，那么在没有加载的时候，代码段、数据段这些也是不会加载进去的。lazy load。 官方解释如下： A better approach is for an app to load code into its address space when it’s actually needed, either at launch time or at runtime. The type of library that provides this flexibility is called dynamic library. 动态库:可以在 运行 or 启动 的时候加载到内存中，加载到一块独立于 app 的内存地址中 When an app is launched, the app’s code—which includes the code of the static libraries it was linked with—is loaded into the app’s address space.Applications with large executables suffer from slow launch times and large memory footprints 静态库：当程序在启动的时候，会将 app 的代码(包括静态库的代码）一起在加载到 app 所处的内存地址上。相比于动态库 的方案，使用静态库将花费更多的启动时间和内存消耗。还会增加可执行文件的大小。 而很多 app 都会使用很多相同的库，如 UIKit 、 CFNetwork 等。所以，苹果为了加快 app 启动速度、减少内存花销、减少安装包体积大小，采用了大量 动态库的形式 来优化系统。dyld 的共享缓存 ：在 OS X 和 iOS 上的动态链接器使用了共享缓存，共享缓存存于 /var/db/dyld/。对于每一种架构，操作系统都有一个单独的文件，文件中包含了绝大多数的动态库，这些库都已经链接为一个文件，并且已经处理好了它们之间的符号关系。当加载一个 Mach-O 文件 (一个可执行文件或者一个库) 时，动态链接器首先会检查 共享缓存 看看是否存在其中，如果存在，那么就直接从共享缓存中拿出来使用。每一个进程都把这个共享缓存映射到了自己的地址空间中。这个方法大大优化了 OS X 和 iOS 上程序的启动时间。 两者都是由*.o目标文件链接而成。都是二进制文件，闭源。 .framework VS .a .a，不能直接拿来使用，需要配合头文件、资源文件一起使用。在 iOS 中是作为静态库的文件名后缀。 .framework中除了有二进制文件之外还有资源文件，可以拿来直接使用。 .tbd VS .dylib 对于静态库的后缀名是.a，那么动态库的后缀名是什么呢？ 可以从 libsqlite3.dylib 这里我们可以知道 .dylib 就是动态库的文件的后缀名。 那么 .tbd 又是什么东西呢？其实，细心的朋友都早已发现了从 Xcode7 我们再导入系统提供的动态库的时候，不再有.dylib了，取而代之的是.tbd。而 .tbd 其实是一个YAML本文文件，描述了需要链接的动态库的信息。主要目的是为了减少app 的下载大小。具体细节可以看这里 Embedded VS. Linked Embedded frameworks are placed within an app’s sandbox and are only available to that app. System frameworks are stored at the system-level and are available to all apps. OK，前面说了那么多，那么如果我们自己开发了一个动态framework 怎么把它复制到 dyld 的共享缓存 里面呢？ 一般来说，用正常的方式是不能滴，苹果也不允许你这么做。（当然不排除一些搞逆向的大神通过一些 hack 手段达到目的） 那么，我们应该如何开发并使用我们自己开发的 动态framework 呢？ 那就是 Embedded Binaries。 Embedded 的意思是嵌入，但是这个嵌入并不是嵌入 app 可执行文件，而是嵌入 app 的 bundle 文件。当一个 app 通过 Embedded 的方式嵌入一个 app 后，在打包之后解压 ipa 可以在包内看到一个 framework 的文件夹，下面都是与这个应用相关的动态framework。在 Xcode 可以在这里设置,图中红色部分： 那么问题又来了，下面的 linded feameworks and libraries 又是什么呢？ 首先在 linded feameworks and libraries 这个下面我们可以连接系统的动态库、自己开发的静态库、自己开发的动态库。对于这里的静态库而言，会在编译链接阶段连接到app可执行文件中，而对这里的动态库而言，虽然不会链接到app可执行文件中，但是会在启动的时候就去加载这里设置的所有动态库。(ps.理论上应该是这样，但是在我实际测试中似乎加载不加载都和这个没关系。可能我的姿势不对。😂) 如果你不想在启动的时候加载动态库，可以在 linded feameworks and libraries 删除，并使用dlopen加载动态库。（dlopen 不是私有 api。） 12345678910111213141516- (void)dlopenLoad&#123; NSString *documentsPath = [NSString stringWithFormat:@"%@/Documents/Dylib.framework/Dylib",NSHomeDirectory()]; [self dlopenLoadDylibWithPath:documentsPath];&#125;- (void)dlopenLoadDylibWithPath:(NSString *)path&#123; libHandle = NULL; libHandle = dlopen([path cStringUsingEncoding:NSUTF8StringEncoding], RTLD_NOW); if (libHandle == NULL) &#123; char *error = dlerror(); NSLog(@"dlopen error: %s", error); &#125; else &#123; NSLog(@"dlopen load framework success."); &#125;&#125; 上面这一点代码调用 也是iOS动态下发代码的基础，会导致无法上架App Store，但是in house 和develop 模式是完全OK的。具体细节这里不再深究。 使用总结静态库 ：.a 和 .framework动态库： .dylib 和 .tbd 和 .framework。 注意！！ 上线App Store的话是不允许自制动态库的。 由于 .a 的使用需要额外依赖头文件以及资源文件，所以并没有 framework 来的方便，在这里不在讨论制作过程，我们以 静态库 framework 的制作为例： 静态库 Framework制作步骤bug: 发现 Xcode 9 以上打出的 Framework 在低版本的 Xcode 工程引入后会出现错误如下： 暂无解决方案，如果出现问题请换回 Xcode 8 去打包。实测Xcode 9.1 依然出现此问题，苹果真是越来越不走心了ㄟ( ▔, ▔ )ㄏ 创建工程打开Xcode(当前版本Xcode 9.1)，创建新工程： 前缀！！前缀！！前缀！！这里需要特别注意的地方是一定一定要注意写上前缀，相信大家都遇到过在引入SDK后出现类重复定义的错误，由于oc并没有命名区间的概念，所以在我们自己创建SDK的时候需要时刻注意着这个问题。 工程设置 Dead Code Stripping 是对程序编译出的可执行二进制文件中没有被实际使用的代码进行Strip操作。如果代码量巨大可以打开这个选项，有助于提升加载速度，但是效果一般，但是如果打开了这个选项代码中就需要避免使用全局变量和静态初始化。所以一般是不启用。 link with standard libraries 如果激活此设置，那么编译器在链接过程中会自动使用通过标准库的链接器。为什么不启用？？？ Mach-o Type 选择 静态库 Static Library ,这里是区分静态库和动态库的主要设置。 在Architectures下增加armv7s，并选中。 将Build Active Architecture Only 设置为NO。 Build Active Architecture Only 设置为NO的时候，会编译支持的所有的版;YES的时候，是为Debug的时候速度更快，它只编译当前的architecture 版本。 编写代码这里我创建一个示例类 LY_SayHi ,所有的类一定要写前缀， .bundle 资源文件资源文件都打包放在这里。在制作Framework的时候不可以把图片直接放在项目中，否则制作好之后图片是一张一张的出现在项目中非常乱，需要新建一个bundle将图片放进去，这里的bundle提供整个SDK的图片资源。 注意：图片放进bundle之后不可以用[UIImage ImageWithName:]读取图片。要先找到bundle包再拿图片。 12345678910111213141516171819//从自己模块的bundle里取出资源，并非mainBundle- (UIImage *)getImageFromBundleWithName:(NSString *)name &#123; NSBundle *bundle = [NSBundle bundleForClass:[self class]];//填写自己的 bundle 名称，主要前缀问题。 NSURL *bundleURL = [bundle URLForResource:@"LY_bundleName" withExtension:@"bundle"]; NSBundle *resourceBundle = [NSBundle bundleWithURL: bundleURL]; NSString *bundlePath = [resourceBundle resourcePath]; NSString *path = [NSString stringWithFormat:@"%@/%@",bundlePath,name]; UIImage *img = [UIImage imageWithContentsOfFile:path]; return img;&#125; 支持bitcode如果自己想要制作支持 Bitcode 的 Framework，仅仅在工程中开启 Enable Bitcode 是不够的，还需要这两步： Build Setting 中 Other Linker Flags 中加入 -fembed-bitcode。 Build Setting 中 Other C Flags 中加入 -fembed-bitcode。 检查静态库是否支持 bitcode,最好的方式就是手动集成到一个demo中，打开demo的bitcode设置，然后直接Archive，如果不出错就说明是支持的，如果出现下面的错误就说明静态库是有问题的。 源码中需要引入 category如果代码中引入了 category ，需要保证: 重要！！！！！ 分类命名一定要有自己的前缀NSDictionary+LY_Category.h 所有的分类方法必须加前缀。避免替换掉工程里同名分类方法的问题。 如果SDk中包含了category，别人在引入你的SDK时需要做如下设置： 静态库依赖其他第三方静态库（Framework和.a）正常导入要打包的文件就可以了，在导入第三方静态库的时候要注意，不要选择添加到target中，如果添加进去要去target里面把第三方静态库删掉（只需导入，不要添加进target） 导入第三方静态库之后再link依赖的系统库，注意顺序： 如果你的依赖库里面有lib开头的dylib动态库，此时应该会报错大概就是没找到对应的库文件，因为tbd是苹果提供的新的动态库格式，之前都是dylib，不知道这里又抽什么风，下面解决问题。先把原来的.tbd删掉，然后再次添加，这个时候选择add other，在弹出的窗口中按快捷键shift + command + G 调出finder的前往窗口，输入/usr/lib，然后添加相应的dylib动态库。 设置Headers把需要暴露出来的头文件拖到public区域，其他的全部放到 project下面，同时需要在自动生成的 xx.framework.h文件中引用所有的公共头文件，如下所示： 打包 Framework步骤：1、 选中模拟器，编译程序2、 选中测试机，编译程序3、 在finder中找到framework文件，show in finder一个是Debug-iphoneos（真机）下的，一个是Debug-iphonesimulator(模拟器)下的。4、 利用lipo命令合并 Framework,找到对应的二进制文件： 12$ lipo -info /Debug-iphoneos/Someframework.framwork/binaryName# Architectures in the fat file: Someframework are: armv7 armv7s arm64 12# 合并$ lipo –create /Debug-iphoneos/Someframework.framwork/binaryName /Debug-iphonesimulator/Someframework.framwork/binaryName –output binaryName #拆分 $ lipo –create binaryName -thin armv7 -output a-output-armv7.framework 以上的操作对象 binaryName 都是Framework目录下的二进制文件，最终生成一个二进制文件，拷贝出一个Framework文件，把生成的二进制替换掉Framework里面的二进制文件，就生成了我们需要的SDK文件。 参考链接iOS 开发中的『库』(一)iOS 开发中的『库』(二)iOS Architectures 浅谈iOS静态库SDK制作（包含第三方静态库） 代码规范性 方法、变量名、宏。类名参数、驼峰 不能做什么 代码块封装 项目 UI 一致性，规范。 UI标注用来开发 产品计图用来理解需求 项目流程规范 版本需求会议：及时暴露问题，明确需求是否可落地。记录清楚讨论结果 。内部需求同步。负责人禅道跟踪。 详细设计，流程图，开发思维，开发角度，记录开发流程。两端同一份详细设计，如果实现不一致需要标明。协调资源。部门联调 改动项目：标注清楚版本号、需求。标注需求详细设计地址 组内自测、交叉功能测试 提交测试部：bug跟踪修复（禅道）、codeReview 灰度上线：两轮上线，保证所有功能正常、完整可用 正式上线 版本总结：记录问题、延迟的需求、开发经验 新人指导 当前需求稍微同步一下 工程结构 规范监督、代码review、周例会检查 需求阶段：预研需求：经理，在技术预研时需要谨慎，确定性、完成率多少整体需求：尽量全部局部需求：相关负责人需求会议负责人，相关需求的人参加 详细设计：需求范围：后台接口？、H5、客户端（iOS？安卓？）那些需求需要详细跟踪。需求部分需要跟踪，但是不是每一个都需要代码实现 开发：详细开发代码要求到具体类，结合git日志可以结合技术分享链接开发者、改动记录注释部分也要按需要添加，复杂度高的尽量详细 自测： 自测深度、严谨 测试部：codeReview阶段？越早越好，上线之后尽量不要改动。有问题的剔除内部需求，下版本修改 版本总结： 正式会议]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Everybody knows]]></title>
    <url>%2F2018%2F01%2F15%2FAboutUs20171130%2F</url>
    <content type="text"><![CDATA[每当被问起，你这么做能改变什么的时候，我便想起哈维尔的话：“我们做一件事，并不是因为这么做会产生结果，而是坚信，这么做是对的”。–电影《出租车司机》 2017年毫无疑问是魔幻现实主义的又一个重要的里程碑，沉默的大多数继续在所谓的“和谐盛世“里娱乐至死，早些年被给予厚望的舆论高地一个个变得“和谐”，不同的声音也已经消失殆尽，新闻联播里面国外依旧战火连天，国内依旧歌舞升平。但在结束了一天的劳累挤在下班的路上，在追的黄金档电视剧结束，或者入睡前的某一刻，当世界突然安静下来，似乎所有人慢慢开始变得躁动与不安，所谓的“希望“只是个笑话，所谓的“和谐”也只是个幌子，Everybody knows…未完待续。。。]]></content>
      <categories>
        <category>About Me</category>
      </categories>
      <tags>
        <tag>About Me</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Nodejs几行代码打造的简易服务器]]></title>
    <url>%2F2017%2F11%2F30%2FHomeMadeTomcat%2F</url>
    <content type="text"><![CDATA[下载一个CodeRuner,运行如下代码 123456789101112131415161718192021222324252627var http = require("http");function onRequest(request, response) &#123; response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); console.log("request: " + request.method); console.log("header: " + JSON.stringify(request.headers)); console.log("url: " + getClientIp(request)); response.write(JSON.stringify(a)); response.end();&#125;http.createServer(onRequest).listen(8888);console.log("Server has started.");function getClientIp(req) &#123; return req.headers['x-forwarded-for'] || req.connection.remoteAddress || req.socket.remoteAddress || req.connection.socket.remoteAddress; &#125;;var a = &#123; provinceCode:"280", cityCode:"0282", iconImgType:"200" &#125; 如下截图：]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fastlane 的安装与使用]]></title>
    <url>%2F2017%2F03%2F17%2FFastlane%2F</url>
    <content type="text"><![CDATA[Mac 环境下 Ruby 的安装与升级检查自己的 Ruby 版本 ruby -v RVM (Ruby Version Manager)Ruby版本管理器来升级ruby，RVM包含了Ruby的版本管理和Gem库管理(gemset)。 RVM安装1curl -L get.rvm.io | bash -s stable 之后就是等待一段时间之后，就可以安装成功了，使用以下命令来验证123source ~/.bashrc然后source ~/.bash_profile 如果没有报错，说明安装正常。 验证版本号1rvm -v 如果出现rvm（版本号）…………..基本就算是安装RVM成功了。 使用RVM升级Ruby列出已知ruby的版本: 1rvm list known 选定自己想要的版本号直接安装，前提是电脑已经安装了 Xcode ，这里需要 Xcode 的命令行工具： 1xcode-select --install 然后执行： 1rvm install 2.4 如果在执行命令是报错， brew update的错误的话，可以按如下方式修改， 参考 12345cd $(brew --prefix)git clean -fdgit reset --hardsudo chown -R `whoami` `brew --prefix`brew update 执行没有问题的话，然后继续执行 rvm install 2.4 过程稍微需要点时间，中间需要手动输入密码和手动按回车。完成后检查版本： 安装 Fastlane如果以上安装正常，也就是在环境：macOS or Linux with Ruby 2.0.0 or above，执行如下命令。参考 1sudo gem install fastlane -NV 安装完成后使用，fastlane --version 检查安装版本。 Fastlane 使用步骤进入到当前的工程目录，project文件所在目录1fastlane init 过程中需要填写项目的 APPID（取消二次验证）、密码以及相关信息，执行完毕后悔生成大致如下的工程目录： Appfile, 用于存放 app ID 和你的 Apple ID。 Fastfile, 用于管理你所创建的 lane，lane 则会调用 action。 Snapfile, 用于指定需要进行屏幕截图的设备类型和语种。 使用 gym 自动打包首先进入工程中，把证书文件配置妥当。打开 Fastfile 添加如下 ，官方参数列表 123lane :beta do gym(scheme: "FindMyCar")# scheme 就是你的 主target名字end 完成后执行 fastlane beta , beta 就是指执行的 lane 的名字。会把打包好的文件放在当前的目录下： 使用 snapshot 截取图片首先在工程目录执行 fastlane snapshot init ,会生成如下文件到目录：然后打开自己的工程，检查有没有添加过 UITest 的target，如果没有就手动添加：File-&gt;New-&gt;target 把生成的./SnapshotHelper.swift文件拖动到该 target 底下：由于该文件是 swift 文件，需要在 Xcode 中配置一下，OC才可以引用该类文件：1、选中targets-&gt;build settings -&gt;packing-&gt;Product Module Name 中设置模块名，这个名称很重要 swift 的头文件就是根据这个来命名的。2、在工程中添加引用头文件 这样，工程中如查Swift要使用OC,则把需要使用的OC类的头文件，全写在MixDemo-Bridging-Header.h里。同样如果OC中所使用的swift类，只需要Clean一遍，再编译就可以了，但不要忘了导入SwiftModule-swift.h哦（名称自取，但-swift.h是固定的），另外还有一个需要读者注意的。参考链接 初始化测试代码在自己的测试类中的 setUp 方法中新增代码如下： 12345XCUIApplication *app = [[XCUIApplication alloc] init];[Snapshot setupSnapshot:app];[app launch];来替换掉系统自带的：[[[XCUIApplication alloc] init] launch]; 完成以后，执行 CMD + U 也就是执行测试，检查是否会报错，如有错误，继续检查以上设置和代码编写。 录制测试流程snapshot 截图的原理其实是在利用 UITest 的录制功能，在相应的地方埋入截图的代码。首先把鼠标焦点放在 testExample 的方法内，在录制的时候代码默认会在鼠标焦点的方法中自动生成。然后点击左下角的录制按钮开始录制的时候，Xcode 会自动启动模拟器，选择你要展示的页面，同时你可以看到自动生成的代码，保证你要截图的地方都被你点出来过就OK了，点击Stop。由于自动生成的代码对中文支持的不好，需要修改所有出现的 Unicode 为中文字符，然后编译，检查是否报错。 插入截图的埋点阅读自动生成的代码，在具体点的代码处埋设截图的代码： 12Swift: snapshot("01LoginScreen")Objective C: [Snapshot snapshot:@"01LoginScreen" waitForLoadingIndicator:YES]; 完成后，按自己的需求编辑 Snapfile文件： 12345678910111213141516171819202122232425262728# A list of devices you want to take the screenshots from devices([ "iPhone 6", "iPhone 6 Plus", ])languages([ "en-US", ["pt", "pt_BR"] # Portuguese with Brazilian locale])# The name of the scheme which contains the UI Tests# scheme "SchemeName"# Where should the resulting screenshots be stored?# output_directory "./screenshots"# clear_previous_screenshots true # remove the '#' to clear all previously generated screenshots before creating new ones# Choose which project/workspace to use project "./FindMyCar.xcodeproj"# workspace "./Project.xcworkspace"# Arguments to pass to the app on launch. See https://github.com/fastlane/snapshot#launch-arguments# launch_arguments(["-favColor red"])# For more information about all available options run# fastlane snapshot --help 完成后执行 fastlane action snapshot。正常结果如下：自动生成的的截图： 获取 git commit 的 log 信息使用Action changelog_from_git_commits来获取 git 的log 信息。配置如下：参考 1234567changelog_from_git_commits( between: ["31c19ab1c5dd01", "HEAD"], # 指定获取log 的节点，不包括选中的节点,区间左开右闭，("31c19ab","HEAD"] pretty: "* (%ae) %s",#格式化输出 date_format: "short", match_lightweight_tag: false, merge_commit_filtering: "exclude_merges" #不截取 merge信息) 执行完成后，Action会返回一个组装好的字符串，输出字符串如下： 发送邮件这里首先介绍一个可以执行 shell 脚本的 Action sh 参考1234sh("git commit -m 'My message'")或者sh("ls")sh("pod install") 以上代码就等同于你打开 terminal 手动输入命令。借助此功能我们可以编写自己的脚本然后自动执行。1sh("python mailTestGroup.py") #执行mailTestGroup.py 这里发邮件的脚本是利用 python 写的，代码如下 ：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# -*- coding: UTF-8 -*-import stringfrom sys import argv#解包传入的参数，拿到标题和文件内容script,title,message = argv#公司SMTP邮件服务器，需要找一下公司的负责人SMTP_SERVER = 'smtp.263.net'SMTP_PORT = 25################################################## 自己手动配置区域，请手动更改为自己的SMTP_USERNAME = 'xxxx@leadeon.cn'SMTP_PASSWORD = 'xxxx'# 发件人，收件人，抄送from_addr = SMTP_USERNAMEto_addrs = ['xxxx@leadeon.cn']acc = ['xxxxx@qq.com','xxxx@qq.com']#附件位置需要和gym输出的路径保持一致attfile = './gym/xxxx.ipa'#标题subject = title#过滤邮件内容 ###为正常提交 ***为bug修复 没有需求的话可以去掉此部分代码 content = message就好了norArr = ''bugArr = '' for log in message.split('\n'): if log.find('###') != -1: log.replace('###','') norArr = norArr + log + '\n' elif log.find('***') != -1: log.replace('***','') bugArr = bugArr + log + '\n'outputMsg = ''if norArr != '': outputMsg = outputMsg + '新提交' + '\n' + norArrif bugArr != '' outputMsg = outputMsg + '修复问题' + '\n' + bugArrcontent = outputMsg################################################## 以下是真正的发送代码，没有必要请勿改动#导入smtplib和MIMEText import smtplib from email.Header import Header from email.MIMEText import MIMEText from email.MIMEMultipart import MIMEMultipart import os.path#创建一个带附件的实例msg = MIMEMultipart() #添加邮件内容 #注意，要指定邮件内容的编码为utf-8，否则中文会有乱码 text_msg = MIMEText(content,'plain','utf-8') msg.attach(text_msg) #构造附件 #注意：传入的参数attfile为unicode，否则带中文的目录或名称的文件读不出来 # basename 为文件名称，由于传入的参数attfile为unicode编码，此处的basename也为unicode编码 basename = os.path.basename(attfile) #注意：指定att的编码方式为gb2312 att = MIMEText(open(attfile, 'rb').read(), 'base64', 'gb2312') att["Content-Type"] = 'application/octet-stream' #注意：此处basename要转换为gb2312编码，否则中文会有乱码。 # 特别，此处的basename为unicode编码，所以可以用basename.encode('gb2312') # 如果basename为utf-8编码，要用basename.decode('utf-8').encode('gb2312') att["Content-Disposition"] = 'attachment; filename=%s' % basename.encode('gb2312') msg.attach(att) #加邮件头 #但是msg['to']并没有在后面被使用，这么写明显是不合理的，但是这就是stmplib的bug。你只有这样写才能群发邮件msg['to'] = ",".join(to_addrs)msg['from'] = from_addrmsg['Cc'] = ",".join(acc)#主题指定utf-8编码，否则中文会有乱码 msg['subject'] = Header(subject, 'utf-8') #发送邮件 server = smtplib.SMTP(SMTP_SERVER) server.login(SMTP_USERNAME, SMTP_PASSWORD)server.sendmail(msg['from'], to_addrs + acc,msg.as_string()) server.close 代码的逻辑这里不再赘述，这里我们需要做的就是更改自己的邮箱和要发送、抄送的人的邮箱，以及附件的存放地址，邮件的title 和 内容是从外面传入进来的。真正的fastlane中的调用方式如下：1234567891011121314lane :mail do #打包到fastlane/gym/下 gym(scheme: "FindMyCar",output_directory: "fastlane/gym/",) #拿到获取到的 log commitLog = changelog_from_git_commits( between: ["31c19ab1c5dd01", "HEAD"], # 指定获取log 的节点，不包括选中的节点 pretty: "* (%ae) %s",# merge_commit_filtering: "exclude_merges" ) #把拿到的log信息包装成字符串 commit = "'" + commitLog + "'" #包装好的log当成邮件内容传递给发邮件的 python 脚本 sh("python mailTestGroup.py '参数测试' #&#123;commit&#125;")end 完成后我们可以调用此条自定义的lane fastlane mail 实际的邮件效果如下： 附加 pbxprojHelper–Xcode工程文件助手在开发公司的项目时，check out 代码到本地后需要修改工程文件。比如更改证书和 Bundle Identifier、删除一些编译不过的 Target，修改 Build Settings 等配置。重复手动修改这些非常耗费时间和没有意义。 需求 将程序员对工程文件做出的配置修改记录下来，并保存成 JSON 文件。 下次使用时直接导入 JSON 文件，将配置修改应用到当前的工程文件上。 支持回滚操作。 工程文件内容的预览、过滤。 提供命令行工具。 pbxprojHelper 工具安装pbxprojHelper Github这里提供了源码和使用方法，我这里在啰嗦一下自己的安装过程以及注意事项。由于工程采用 swift3 编写，这里你的mac OS 需要在 10.12以上。操作如下：下载APP 和 命令行工具，如果不需要刻意不下载 命令行工具。完成以后将 pbxproj 移到 /usr/local/bin/ 目录, 这样你就能方便地在终端中执行 pbxproj 命令了。这里需要注意的是需要给pbxproj 赋予一定的权限才可以正常执行。打开 terminal 输入：12cd /usr/local/bin/chmod a+x pbxproj 执行完以后在 terminal 输入 pbxproj 命令，如果出现如下效果，就表示安装成功了。 pbxprojHelper 工具使用把下载好的AP直接打开就可直接使用，这里我们第一步要去生成一个 记录差异化的的json配置文件。打开window-&gt;Json Configuration Generator：选择原始的工程文件和修改后的工程文件并且指定配置文件的输出路径，点击 Generator 就可以生成json配置文件。完成以后，基础的配置就算完成了。一般我们的工作流程是： 更新代码。 开发自己的模块。 开发完成需要真机调试或者需要出包时，切换到自己的证书配置环境。选择需要切换环境的工程文件，选择机的JSON配置文件，点击apply即可切换。！！！这里建议不要关闭APP，需要全程保持，以免出现后面无法revert的情况。 没有问题的话准备提交，首先 revert自己的工程配置，然后提交代码。基本上到这里app的用法就说完了，下面介绍一下命令行的使用： 123456#生成json配置文件pbxproj my.xcodeproj -compare modified_file -o jsonPath#应用差异化文件配置文件pbxproj -apply my.xcodeproj JsonConfiguration.json#还原到以前的工程文件 pbxproj -revert my.xcodeproj 参考链接fastlane 官网fastlane DOCpbxprojHelper–Xcode工程文件助手]]></content>
      <categories>
        <category>Fastlane Ruby</category>
      </categories>
      <tags>
        <tag>Fastlane</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS X 10.12.1 安装cocoapods]]></title>
    <url>%2F2017%2F02%2F25%2FCocoapods%2F</url>
    <content type="text"><![CDATA[2016年11月17日 ，原淘宝的镜像已经失效，最新： 1http://gems.ruby-china.org/ 1、请尽可能用比较新的 RubyGems 版本，建议 2.6.x 以上.123$ gem update --system # 这里请翻墙一下$ gem -v2.6.3 2、替换下载的路径，把上面的链接拿过来123456$ gem sources -lhttps://xxxxxx.org #检查自己的 -l的链接$ gem sources --add http://gems.ruby-china.org/ --remove https://xxxxxx.org$ gem sources -lhttps://gems.ruby-china.org# 确保只有 https://gems.ruby-china.org 3、开始安装1sudo gem install cocoapods 如果一切正常，那就恭喜了！ 如果出现以下错误:12ERROR: While executing gem ... (Errno::EPERM)Operation not permitted - /usr/bin/xcodeproj 解决方案： 123sudo gem install -n /usr/local/bin cocoapodspod setup 还有一点需要注意，pod setup在执行时，会输出Setting up CocoaPods master repo，但是会等待比较久的时间。这步其实是 Cocoapods 在将它的信息下载到 ~/.cocoapods目录下，如果你等太久，可以试着 cd 到那个目录，用du -sh *来查看下载进度。如果安装成功,你会看到:Setup completed。那么恭喜了。 如果失败了，会出现：123456[!] /usr/bin/git clone https://github.com/CocoaPods/Specs.git master Cloning into 'master'... error: RPC failed; curl 56 SSLRead() return error -36fatal: The remote end hung up unexpectedlyfatal: early EOFfatal: index-pack failed 保证你电脑上只有一个Xcode,然后 123sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer# 然后继续pod setup 如果多个Xcode,猛击http://blog.csdn.net/wm9028/article/details/51840759 不出意外，你应该可以看到 Setup completed。检查下自己的pod 版本: 12pod --version1.1.1 OK 安装成功 Cocoapods 简单使用cd 到工程根目录1vim Podfile Cocoapods老用户可能需要注意一下，Podfile的写法现在统一为：12345678platform :ios, '8.0'#use_frameworks!个别需要用到它，比如reactiveCocoatarget 'MyApp' do pod 'AFNetworking', '~&gt; 2.6' pod 'ORStackView', '~&gt; 3.0' pod 'SwiftyJSON', '~&gt; 2.3'end vim 环境编辑完 ESC 退出输入模式，“：wq” 保存退出 pod install完成后用新的工程文件打开工程，在import头文件时，如果没有智能提示，需要在 Xcode 里工程文件做一下配置TARGETS -&gt; Search Paths -&gt; User Header Search Paths 中 写入 ${SRCROOT} 再将后面参数改为recursive 参考资料Mac OS X 10.12.1 安装cocoapods及使用详解Ruby-china镜像安装cocoapods遇到error]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS,macOS相关Tips]]></title>
    <url>%2F2016%2F12%2F29%2FCommand%2F</url>
    <content type="text"><![CDATA[其他常用的Terminal命令查看本机IP ifconfig en0模拟器调试3D-Touch echo &#39;com.apple.mobilecal&#39; | nc 127.0.0.1 8000 MarkDown文件生成HTML文件12sudo gem install tocmd //安装tocmd工具sudo tocmd_local -f test.md //当前目录下 Xcode相关Xcode清理 删除Xcode中多余的证书provisioning profile 的path：~/Library/MobileDevice/Provisioning Profiles 清理Xcode编译项目产生的缓存垃圾~/Library/Developer/Xcode/DerivedData vvdocument 有时安装不成功,需要重置一下defaults delete com.apple.dt.Xcode DVTPlugInManagerNonApplePlugIns-Xcode-{your_xcode_version} 常用代码块123456//TODO: 分享当页截图UIWindow *screenWindow = [[UIApplication sharedApplication] keyWindow];UIGraphicsBeginImageContext(screenWindow.frame.size);[screenWindow.layer renderInContext:UIGraphicsGetCurrentContext()];UIImage *scImage = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext(); 1print 'Hello world' Xcode常用快捷键 项目之间切换 cmd+~ .h和.m之间切换 ctrl+cmd+ ↑ or ↓ 定位类文件 cmd+shift+J 类文件查找 cmd+shift+O Xcode对应架构123lipo -info xxx.a //查看支持什么架构otool -L xxx.a //查看.a包含什么类lipo -create xxx.a yyy.a -output zzz.a//合并不同架构的静态库 armv7 , armv7s对应真机的32位处理器 arm64对应真机的64位模拟器 i386对应模拟器的32位模拟器 x86_64对应模拟器的64位模拟器 bitcode相关 生成静态库或者framwork时不仅要打开bitcode为yes，还需要设置参数如下： -fembed-bitcode 检查生成的库是否是支持bitcode的1234567otool -arch armv7 -l xxxx.a | grep __bitcode | wc -l 或者otool -arch i386 -l xxxx.a | grep __bitcode | wc -l 或者otool -arch x86_64 -l xxxx.a | grep __bitcode | wc -l或者otool -arch arm64 -l xxxx.a | grep __bitcode | wc -l 如果当前库支持Bitcode .a文件就会输出一个数字 参考链接 iOS相关从源码到APP 当我们点击了 build 之后，做了什么事情呢？ 预处理（Pre-process）：把宏替换，删除注释，展开头文件，产生 .i 文件。 编译（Compliling）：把之前的 .i 文件转换成汇编语言，产生 .s文件。 汇编（Asembly）：把汇编语言文件转换为机器码文件，产生 .o 文件。 链接（Link）：对.o文件中的对于其他的库的引用的地方进行引用，生成最后的可执行文件（同时也包括多个 .o 文件进行 link）。 Build phases &amp;&amp; Build rules &amp;&amp; Build settings Build phases: 主要是用来控制从源文件到可执行文件的整个过程的，所以应该说是面向源文件的，包括编译哪些文件，以及在编译过程中执行一些自定义的脚本什么的。 Build rules: 主要是用来控制如何编译某种类型的源文件的，假如说相对某种类型的原文件进行特定的编译，那么就应该在这里进行编辑了。同时这里也会大量的运用一些 xcode 中的环境变量，完整的官方文档在这里：Build Settings Reference Build settings:则是对编译工作的细节进行设定，在这个窗口里可以看见大量的设置选项，从编译到打包再到代码签名都有，这里要注意 settings 的 section 分类，同时一般通过右侧的 inspector 就可以很好的理解选项的意义了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 学习笔记]]></title>
    <url>%2F2016%2F07%2F29%2FThis%20Python%2F</url>
    <content type="text"><![CDATA[支持中文显示1234567# This Python file uses the following encoding: utf-8or# -*- coding: utf-8 -*-or# coding=&lt;coding name&gt;orvim: set fileencoding=&lt;encoding name&gt; : 判断一个 list 是否为空123456789101112传统的方式：if len(mylist): # Do something with my listelse: # The list is empty由于一个空 list 本身等同于 False，所以可以直接：if mylist: # Do something with my listelse: # The list is empty 读取json文件并写入另一个txt123456789101112131415161718import jsonf = file("getVideoOfChapters.json");#loads 方法参数是 json串s = json.load(f)print s.keys()f.close()print s["videos"][1]["videoName"]target = open("test.txt", 'a')target.write("name")for video in s["videos"]: ss = video["videoName"] print (ss) #写入的时候记得转码 target.write(ss.encode('utf-8')) target.write("\n")target.close()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 操作练习]]></title>
    <url>%2F2016%2F07%2F25%2FgitTest%2F</url>
    <content type="text"><![CDATA[安装Git创建版本库什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 所以，创建一个版本库非常简单， 选择一个合适的地方，创建一个空目录：通过git init命令把这个目录变成Git可以管理的仓库12$ git initInitialized empty Git repository in /Users/lyl/test/.git/ 命令git add告诉Git，把文件添加到仓库1$ git add readme.txt 命令git commit告诉Git，把文件提交到仓库1234$ git commit -m "wrote a readme file"[master (root-commit) cb926e7] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt git status命令可以让我们时刻掌握仓库当前的状态123456789$ git status# On branch master# Changes not staged for commit:# (use "git add &lt;file&gt;..." to update what will be committed)# (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)## modified: readme.txt#no changes added to commit (use "git add" and/or "git commit -a") git status命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 git diff这个命令查看上次修改123456789$ git diff readme.txt diff --git a/readme.txt b/readme.txtindex 46d49bf..9247db6 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system. Git is free software. git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。 或者，提交后，用git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别： 用git log命令查看历史记录123456789101112131415161718$ git logcommit 3628164fb26d48395383f8f31179f24e0882e1e0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Tue Aug 20 15:11:49 2013 +0800 append GPLcommit ea34578d5496d7dd233c827ed32a8cd576c5ee85Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Tue Aug 20 14:53:12 2013 +0800 add distributedcommit cb926e7ea50ad11b8f9e909c05226233bf755030Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Mon Aug 19 17:51:55 2013 +0800 wrote a readme file git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。 –pretty=oneline参数,可以只显示 版本号 + 注释1234$ git log --pretty=oneline3628164fb26d48395383f8f31179f24e0882e1e0 append GPLea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributedcb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file 需要友情提示的是，你看到的一大串类似3628164…882e1e0的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 回退版本 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 使用git reset命令,回退到上一个版本12$ git reset --hard HEAD^HEAD is now at ea34578 add distributed –hard 参数有啥意义？这个后面再讲，现在你先放心使用 回到已有的任意版本最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？ 办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是3628164…，于是就可以指定回到未来的某个版本： 12$ git reset --hard 3628164HEAD is now at 3628164 append GPL 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？在Git中，总是有后悔药可以吃的。当你用$ git reset –hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令： 12345$ git reflogea34578 HEAD@&#123;0&#125;: reset: moving to HEAD^3628164 HEAD@&#123;1&#125;: commit: append GPLea34578 HEAD@&#123;2&#125;: commit: add distributedcb926e7 HEAD@&#123;3&#125;: commit (initial): wrote a readme file git checkout – file可以丢弃工作区的修改：撤销工作区的修改回到上一次 add 或者 commit1$ git checkout -- readme.txt 命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 撤销掉（unstage）暂存区的修改，重新放回工作区。清空某文件的暂存区123$ git reset HEAD readme.txtUnstaged changes after reset:M readme.txt git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 回退小结： 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，版本回退git reset –hard 3628164，不过前提是没有推送到远程库。 删除确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit 123456$ git rm test.txt //版本库中删除rm 'test.txt' //本地删除文件$ git commit -m "remove test.txt"[master d17efd8] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本 1$ git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F07%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[自己博客诞生的第一天。Hello World！当然Welcome to my world！ 像每一个小男孩一样，我也有着一颗向往Make somthing的愿望或者理想吧，虽然我现在不算小也不再是个男孩，但初心未改，内心依然向往一切酷酷的东西。有人解释这种东西叫造物情怀，很长一段时间由于自己能力或者见识的问题，自己虽然苦苦追寻，但并没有任何领悟的迹象。我向来把问题归咎于自己的品味和审美，但是直到我看到一句话，也就是开头的那张图。Build product with love，如果说有个词可以形容那种豁然开朗的感觉，我感觉应该是顿悟，那种感觉很棒，你不在对这个问题迷茫，并且充满了动力。说了这么多，也就是想解释下这个博客诞生的最根本原因。 按照行业内的做法，个人博客大多是用来交流和分享自己的技术所得以及经验。但我感觉局限于技术分享还是有点太geek了，所以呢，这个博客我的初步想法应该是: 个人日志 人生感言，心灵鸡汤来一碗？ iOS技术经验 工作中遇到的那些 坑！！！ 吐槽 不吐槽的人生是不完美的，题材不限，主题不限，随时开火 暂时想到这么多吧，有点小兴奋~~ have fun :)]]></content>
      <categories>
        <category>About Me</category>
      </categories>
      <tags>
        <tag>Hello World</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试测试]]></title>
    <url>%2F2015%2F12%2F23%2FMy-New-Post%2F</url>
    <content type="text"><![CDATA[Blockquote Text1 欢迎使用马克飞象@(示例笔记本)[马克飞象|帮助|Markdown] 马克飞象是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述： 功能丰富 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 得心应手 ：简洁高效的编辑器，提供[桌面客户端][1]以及[离线Chrome App][2]，支持移动端 Web； 深度整合 ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。 Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Cmd + /查看帮助。 代码块12345678910@requires_authorizationdef somefunc(param1='', param2=0):'''A docstring'''if param1 &gt; param2: # interestingprint 'Greater'return (param2 - param1 + 1) or Noneclass SomeClass:pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX 公式可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式： $$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图1st=&#62;start: Start&#10;e=&#62;end&#10;op=&#62;operation: My Operation&#10;cond=&#62;condition: Yes or No?&#10;&#10;st-&#62;op-&#62;cond&#10;cond(yes)-&#62;e&#10;cond(no)-&#62;op 以及时序图: 1Alice-&#62;Bob: Hello Bob, how are you?&#10;Note right of Bob: Bob thinks&#10;Bob--&#62;Alice: I am good thanks! 提示：想了解更多，请查看流程图[语法][3]以及时序图[语法][4]。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： [x] 已完成事项 [ ] 待办事项1 [ ] 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Cmd + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Cmd + /同步文档 Cmd + S创建文档 Cmd + Opt + N最大化编辑器 Cmd + Enter预览文档 Cmd + Opt + Enter]]></content>
      <categories>
        <category>About Me</category>
      </categories>
      <tags>
        <tag>About Me</tag>
      </tags>
  </entry>
</search>
